// deno-lint-ignore-file no-explicit-any
// Generate bindings.ts from raylib_api.json (raylib 5.5)

type Native = Deno.NativeType | "void";

const apiPath = new URL("./raylib_api.json", import.meta.url);
const api = JSON.parse(Deno.readTextFileSync(apiPath));

const aliasMap = new Map<string, string>(
  api.aliases.map((alias: { name: string; type: string }) => [
    alias.name,
    alias.type,
  ]),
);

const structMap = new Map<string, any>(
  api.structs.map((struct: any) => [struct.name, struct]),
);

const callbackSet = new Set<string>(api.callbacks.map((cb: any) => cb.name));

const primitiveMap: Record<string, Native> = {
  "void": "void",
  "bool": "u8",
  "char": "i8",
  "unsigned char": "u8",
  "short": "i16",
  "unsigned short": "u16",
  "int": "i32",
  "unsigned int": "u32",
  "long": "i64",
  "float": "f32",
  "double": "f64",
};

function resolveAlias(type: string): string {
  let current = type;
  const seen = new Set<string>();
  while (aliasMap.has(current) && !seen.has(current)) {
    seen.add(current);
    current = aliasMap.get(current)!;
  }
  return current;
}

function flattenType(type: string, seen = new Set<string>()): Native[] {
  let t = type.trim();

  // strip const for resolution purposes
  t = t.replace(/^const\s+/, "").trim();

  const arrayMatch = t.match(/^(.*)\[(\d+)\]$/);
  if (arrayMatch) {
    const base = arrayMatch[1].trim();
    const count = Number(arrayMatch[2]);
    const inner = flattenType(base, seen);
    const out: Native[] = [];
    for (let i = 0; i < count; i++) out.push(...inner);
    return out;
  }

  if (t.includes("...")) return [];

  // pointers
  if (t.includes("*")) {
    if (/char\s*$/.test(t.replace(/\*/g, "").trim())) return ["buffer"];
    return ["pointer"];
  }

  t = resolveAlias(t);

  if (callbackSet.has(t)) return ["function"];

  const primitive = primitiveMap[t];
  if (primitive) return [primitive];

  const struct = structMap.get(t);
  if (struct) {
    if (seen.has(t)) return ["pointer"];
    seen.add(t);
    const fields: Native[] = [];
    for (const field of struct.fields) {
      fields.push(...flattenType(field.type, seen));
    }
    seen.delete(t);
    return fields;
  }

  return ["pointer"];
}

function ffiType(type: string): Native | { struct: Native[] } {
  const flat = flattenType(type);
  if (flat.length === 0) return "void";
  if (flat.length === 1) return flat[0];
  return { struct: flat };
}

const getDefineValue = (name: string) =>
  api.defines.find((d: any) => d.name === name)?.value;

const major = getDefineValue("RAYLIB_VERSION_MAJOR");
const minor = getDefineValue("RAYLIB_VERSION_MINOR");
const patch = getDefineValue("RAYLIB_VERSION_PATCH");
const version = getDefineValue("RAYLIB_VERSION");

let result = "// This file is generated by generator.ts\n\n";

result += "// --- Version constants ---\n";
result += `export const RAYLIB_VERSION_MAJOR = ${major};\n`;
result += `export const RAYLIB_VERSION_MINOR = ${minor};\n`;
result += `export const RAYLIB_VERSION_PATCH = ${patch};\n`;
result += `export const RAYLIB_VERSION = ${JSON.stringify(version)};\n\n`;

result += `const DLL_TYPE = ({
  windows: "raylib.dll",
  linux: "libraylib.so",
  darwin: "libraylib.dylib",
} as Record<string, string>)[Deno.build.os];

export const lib = Deno.dlopen(
  "./blobs/" + DLL_TYPE,
  {\n`;

for (const fn of api.functions as any[]) {
  if (
    fn.returnType.includes("...") ||
    fn.params?.some((p: any) => p.type.includes("..."))
  ) {
    continue;
  }

  const parameters = (fn.params ?? []).map((param: any) =>
    JSON.stringify(ffiType(param.type))
  ).join(", ");

  result += `\t// ${fn.description ?? ""}\n`;
  result += `\t${fn.name}: { parameters: [${parameters}], result: ${
    JSON.stringify(ffiType(fn.returnType))
  } },\n`;
}

result += "  },\n);\n\n";

result += "// Write the result to the bindings file\n";
const outputPath = new URL("./bindings.ts", import.meta.url);
Deno.writeTextFileSync(outputPath, result);
